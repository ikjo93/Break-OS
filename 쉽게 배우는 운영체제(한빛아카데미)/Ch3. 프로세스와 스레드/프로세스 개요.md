### 프로세스
+ 운영체제에서 프로세스는 하나의 작업 단위(태스크, task)이며 각 프로세스는 여러 상태를 거침
+ 프로그램 : 저장장치에 저장되어 있는 정적인 상태
+ 프로세스 : 실행을 위해 메모리에 올라온 동적인 상태
+ 운영체제 역시 프로그램이므로 프로세스 형태로 실행됨(by 부트스트랩)
+ 일반 사용자의 사용자 프로세스(user process)와 운영체제의 커널 프로세스(kernel process)가 혼합 실행

<br>

### 일괄 작업 방식에서의 프로세스 처리
+ 한 번에 하나의 프로세스만 처리
+ 프로세스의 상태 : 생성(create), 실행(run), 완료(terminate)

<br>

### 시분할 방식에서의 프로세스 처리
+ CPU가 1개인 컴퓨터에서 여러 개의 프로세스를 (거의) 동시에 실행하는 것
+ 프로세스의 상태 : 생성(create), 준비(ready), 실행(run), 대기(blocking), 완료(terminate)
+ 현대 운영체제의 프로세스 처리 방식

<br>

### 프로그램에서 프로세스로 전환되는 과정
+ 운영체제는 프로그램을 메모리의 적당한 위치로 가져오고 동시에 운영체제 영역에 프로세스 제어 블록(PCB, Process Control Block)을 생성
  + 프로세스 제어 블록 : 프로세스를 처리하는 데 필요한 다양한 정보를 저장한 데이터 구조
+ 프로세스 = 프로그램 + 프로세스 제어 블록
+ 프로그램 = 프로세스 - 프로세스 제어 블록

<br>

### 프로세스 제어 블록 내 대표적인 정보
+ 프로세스 구분자(PID) : 각각의 프로세스를 구분하는 구분자(ID)
+ 메모리 관련 정보 : 프로세스의 메모리 위치 정보, 메모리 보호를 위한 경계 레지스터와 한계 레지스터
+ 각종 중간값 : 프로그램 카운터(다음에 작업해야 할 코드의 위치가 담긴 레지스터), 작업의 중간값을 보관 중인 레지스터

<br>

### 프로세스의 활성 상태
+ 생성 상태(create status)
  + 프로세스가 메모리에 올라와 실행 준비를 완료한 상태
  + 프로세스를 관리하는 데 필요한 프로세스 제어 블록 생성
  + 프로세스가 실행되기 전 프로세스 제어 블록과 함께 준비 상태에서 대기
+ 준비 상태(ready status)
  + 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
  + 프로세스 제어 블록은 준비 큐(ready queue)에서 대기
  + CPU 스케줄러는 준비 상태에 있는 여러 프로세스들 중 다음에 실행할 프로세스를 선정(디스패치, dispatch)
+ 실행 상태(running status, execute status)
  + 준비 상태에 있는 프로세스 중 하나가 일정 시간 동안 CPU를 얻어 실제 작업을 수행하는 상태
    + 준비 상태에 있는 프로세스 중 실행 상태에 들어갈 수 있는 프로세스는 CPU의 개수와 동일
  + 주어진 시간으로 모든 작업이 처리되지 않을 경우(타임아웃, timeout) 준비 상태로 돌아와 다음 차례 대기
  + 프로세스에 배정된 작업 시간 : 타임 슬라이스 or 타임 퀀텀
  + 새로운 프로세스가 실행 상태로 오면 CPU는 클록에 일정 시간(타임 슬라이스) 이후(타임아웃) 알려달라고(인터럽트) 요청
+ 대기 상태(blocking status)
  + 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태
  + 대기 상태의 프로세스는 입출력 장치별 큐에서 대기
  + 입출력을 요청한 프로세스가 대기 상태로 옮겨지면 CPU 스케줄러는 준비 상태에 있는 프로세스 중 하나를 실행 상태로 만듬
  + 입터럽트 시스템에서 프로세스가 입출력을 요구하면 CPU가 직접 데이터를 가져오지 않고 입출력 관리자에게 위임
  + 대기 상태의 프로세스는 요청한 입출력이 완료되면 입출력 관리자로부터 인터럽트를 받고 준비 상태로 돌아감
    + 입출력 완료 시 인터럽트 발생(대기 상태 → 준비 상태)
+ 완료 상태(terminate status)
  + 실행 상태의 프로세스가 주어진 시간으로 모든 작업을 처리한 상태
  + 코드와 사용했던 데이터를 메모리에서 삭제 및 프로세스 제어 블록 폐기
  + 오류 내지 강제 종료(abort)를 만나면 디버깅 위해 강제 종료 직전의 메모리 상태를 저장장치로 옮김(코어 덤프, core dump)

<br>

### 프로세스의 휴식 상태
+ 프로세스가 작업을 일시적으로 쉬고 있는 상태(종료 X, 잠시 멈춘 것)
  + 유닉스 Ctrl + Z
+ 사용하던 데이터가 메모리에 그대로 있고 프로세스 제어 블록도 유지(재시작 가능)
+ (참고) 유닉스 프로그램 강제 종료 명령어 Ctrl + C

<br>

### 프로세스의 보류 상태
+ 프로세스가 메모리에서 잠시 쫓겨난 상태 스왑 영역(swap area)에 보관된 상태
+ 일시 정지 상태
+ 대표적인 상황
  + 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
  + 프로그램에 오류가 있어 실행을 미루어야 할 때
  + 바이러스 등 프로세스로 판단될 때
  + 메모리 밖으로 쫓아내도 큰 문제가 없는 프로세스일 경우
  + 입출력을 기다리는 프로세스의 입출력이 계속 지연될 경우
+ 휴식 상태와의 차이 : 프로세스가 메모리가 아닌 스왑 영역에 존재
+ 보류 대기 상태(대기 상태 → 보류 상태) 및 보류 준비 상태(준비 상태 → 보류 상태)
+ 보류 대기 상태에서 입출력 완료 시 보류 준비 상태로 이동
