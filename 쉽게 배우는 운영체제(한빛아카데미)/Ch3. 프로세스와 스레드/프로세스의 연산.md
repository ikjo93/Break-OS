### 프로세스의 구조
+ 코드 영역
  + 프로그래머가 작성한 프로그램의 본문(코드) 데이터 저장(텍스트 영역)
  + 읽기 전용
+ 데이터 영역
  + 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터 저장
  + 본문에 사용되는 데이터 저장
  + 읽기 및 쓰기 가능(상수는 읽기 전용)
+ 스택 영역
  + 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터 저장
  + 숨김 영역

<br>

### 프로세스의 생성
+ 프로세스는 프로그램을 실행할 때 새로 생성
+ 사용자가 프로그램을 실행하면 운영체제가 프로그램을 메모리로 가져와 코드 영역에 넣고 프로세스 제어 블록을 생성
+ 이후 메모리에 데이터 영역과 스택 영역 확보 후 프로세스 실행

<br>

### 실행 중인 프로세스 복사
+ fork() 시스템 호출 : 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
  + 커널에서 제공하는 함수로 일종의 시스템 호출
+ 프로세스를 새로 실행하는 속도보다 복사하는 속도가 훨씬 빠름
+ (example) 크롬을 이용하다가 크롬을 하나 더 생성하면 이는 기존 크롬으로부터 복사된 것
+ 프로세스 복사 시 기존 프로세스는 `부모 프로세스`, 새로 생성된 프로세스는 `자식 프로세스`
  + 두 프로세스는 부모-자식 관계로 연결

<br>

### fork() 시스템 호출
+ 프로세스 제어 블록을 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 생성
+ 자식 프로세스의 정보 중 부모 프로세스와 다른 것
  + 프로세스 구분자(PID)
  + 메모리 관련 정보(메모리 위치)
  + 부모 프로세스 구분자(PPID)와 자식 프로세스 구분자(CPID)
+ 장점
  + 프로세스의 생성 속도가 빠름(하드디스크 X 기존 메모리에서 복사)
  + 추가 작업 없이 부모 프로세스의 모든 자원 상속 가능
  + 시스템 관리 효율화(자식 프로세스 종료 시 해당 자원을 부모 프로세스가 정리)
  
<br>

### exec() 시스템 호출
+ 기존의 프로세스를 새로운 프로세스로 전환하는 함수
+ 프로세스의 구조체를 재활용하기 위해 사용
+ 이미 만들어진 프로세스 제어 블록(PID, PPID, CPID 등), 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있음
  + 새로운 프로세스로 전환하더라도 프로세스 제어 블록의 각종 구분자가 변경되지 않기 때문에 종료 후 부모 프로세스로 돌아올 수 있는 것
+ 새로운 코드 영역 가져옴(운영체제 작업 수월)
+ 데이터 영역이 새로운 변수로 채워지고 스택 영역 리셋

<br>

### 프로세스의 계층 구조(유닉스)
+ init 프로세스 : 전체 프로세스의 출발점 → 프로세스를 효율적으로 관리
  + 나머지 모든 프로세스를 init 프로세스의 자식으로 만듬
  + fork()와 exec() 시스템 호출을 이용하여 자식 프로세스 생성(login 프로세스, shell 프로세스 등)

<br>

### 프로세스 계층 구조의 장점
+ 동시에 여러 작업 처리
  + exec() 시스템 호출을 통해 login 프로세스의 구조를 shell 프로세스로 다시 활용
+ 종료된 프로세스 자원 회수 용이
  + 프로세스 간의 책임 관계 명확
  + 모든 프로세스를 부모-자식 관계로 하여 자식 프로세스가 작업 종료 시 부모 프로세스가 해당 자원 회수

<br>

### 고아 프로세스(or 좀비 프로세스)
+ 부모 프로세스가 먼저 종료되거나 자식 프로세스가 비정상적으로 종료되어 부모 프로세스에 연락이 안 되는 경우
+ 자식 프로세스가 종료되지 않거나, 종료되었는데도 사용하던 자원이 남는 문제 발생
+ C언어의 exit() 또는 return()문은 자식 프로세스가 작업이 끝났음을 부모 프로세스에 알리는 것
  + 부모 프로세스는 미루어왔던 자원 정리나 자식 프로세스와의 동기화 가능
